# Q&A

개발 중 나온 질문과 답변 모음

---

## CSS Modules를 선택한 이유는?

CSS 스타일링 방식은 여러 가지가 있다.

| 방식                  | 장점                                  | 단점                          |
| --------------------- | ------------------------------------- | ----------------------------- |
| **CSS Modules**       | 스코프 격리, 러닝커브 낮음, 번들 작음 | CSS만 알아야 함               |
| **Tailwind CSS**      | 빠른 개발, 유틸리티 기반              | 클래스 길어짐, 초기 설정 필요 |
| **styled-components** | JS 내 스타일, 동적 스타일 쉬움        | 런타임 오버헤드, 번들 커짐    |
| **일반 CSS**          | 가장 단순                             | 클래스 충돌 위험              |

CSS Modules를 선택한 이유:

1. **스코프 자동 격리** — `.module.css` 파일의 클래스명은 빌드 시 자동으로 고유한 이름으로 변환되어 다른 컴포넌트와 충돌하지 않는다.
2. **추가 설치 불필요** — Vite에 기본 내장. 설정 없이 `.module.css`만 쓰면 바로 동작.
3. **순수 CSS** — 새로운 문법 없이 기존 CSS 지식 그대로 사용.
4. **Canvas 앱 특성** — 캔버스 자체는 CSS보다 JS로 제어하고, UI가 많지 않아 Tailwind의 장점이 크지 않음. 런타임 성능이 중요한 앱이므로 순수 CSS가 유리.

---

## CSS width/height 100%와 canvas.width 설정의 차이는?

`<canvas>`는 크기를 결정하는 두 가지 독립적인 값이 있다.

### CSS width/height — 화면에 보이는 크기

```css
canvas {
  width: 100%;
  height: 100%;
}
```

화면에 얼마나 크게 표시할지. 마치 이미지를 늘리는 것과 동일.

### canvas.width / canvas.height — 실제 드로잉 버퍼 해상도

```js
canvas.width = parent.clientWidth;
canvas.height = parent.clientHeight;
```

내부적으로 그릴 수 있는 픽셀 수. 설정하지 않으면 기본값은 **300 x 150**.

### CSS만 쓰면 생기는 문제

```
실제 버퍼: 300 x 150 (기본값)
CSS 표시: 1440 x 900 (화면 크기)
→ 300픽셀짜리 그림을 1440으로 늘린 것 → 흐릿하게 깨짐
```

마우스 좌표 불일치 문제도 발생한다:

```
마우스를 (500, 300) 위치에서 클릭
  CSS 기준 좌표: (500, 300)
  실제 버퍼 좌표: ≈ (104, 50)
  → 클릭한 위치와 그려지는 위치가 어긋남
```

### 올바른 방법

CSS `width/height`는 불필요하다. JS로만 설정하면 충분하다.

```js
canvas.width = parent.clientWidth;
canvas.height = parent.clientHeight;
```

CSS에서는 `display: block`만 지정한다. (`<canvas>`의 기본값이 `inline`이라 제거하지 않으면 하단에 미세한 여백이 생김)

---

## 버퍼(Buffer)란?

**데이터를 임시로 저장하는 메모리 공간.**

Canvas에서는 "그림 데이터를 저장하는 메모리"라고 이해하면 된다.

### 비유

```
버퍼 = 실제 종이 크기 (A4, A3...)
CSS  = 종이를 사진으로 찍어서 화면에 보여주는 크기
```

A4 종이에 그린 그림을 A0 크기로 화면에 띄우면 흐릿하게 보이는 것과 동일한 원리.

### Canvas 버퍼 구체적으로

```js
canvas.width = 800;
canvas.height = 600;
// → 메모리에 800 × 600 = 480,000개의 픽셀 공간 생성
```

`ctx.fillRect()` 같은 명령은 이 메모리에 색상 데이터를 쓰고, 화면은 이 메모리를 읽어서 표시한다.
